# Testing

To initiate testing script, type `make test` in the top level directory (given that you've changed the proper variables in testing.sh for your own tests, if needed). Make sure that the creator does not have a DEBUG flag enabled during compilation. Otherwise, fuzz-testing will not work. The DEBUG print statements from creator will mess with piping when going to solver.

You can also call `./testing.sh <n>` where n is the number of fuzzqueries to generate on your own without calling `make test`. `make test` simply just calls `./testing.sh 3` to generate a default of 3 fuzzqueries.

To initiate a valgrind check, type `make valgrind` in this directory to see memory usage.

Note: I generated testing.out with a debug flag. If you remove the debug flag in the makefile, some of the extraneous outputs will be gone which allow you to see some of the inner steps.

Also note: testing.sh automatically pipes all output to testing.out without the need for it on the terminal. Thus, if you want to generate more fuzzqueries than the default, just use `./testing.sh <n>` replacing n with the number of fuzzqueries to generate.

Please see testing.out and testing.sh for detailed descriptions of test cases, though a simple verbatim test case is given below.

In short, I tested the following cases:
 - Invalid parameters passed to sudoku
 - Ask creator to create a puzzle
 - Invalid stdin format passed to sudoku solve. Expect error msg.
 - Ask solver to solve a pre-set puzzle with a unique solution, and compare output, expecting the same output as the solution.
 - Ask solver to solve a pre-set puzzle with multiple solutions, and compare output of first solution found, as well as noting that  our program detected multiple solutions.
 - Ask solver to solve a pre-set puzzle with no solutions, our program should tell us "no solutions".
 - Invalid puzzle passed to sudoku solve (right off the bat, there are multiple numbers in the same row/col/grid). Expect error msg.
 - 'n' fuzztests generated by creator - all should generate unique solutions as indicated by print statements in output.


Light commentary on some test cases: 

Based on what is visible to the output, our solver does not change any given values.

Additionally, for a solution to be found, the puzzle MUST be valid (based on our recursive algorithm logic, and ALSO we check whether or not the puzzle is valid before we even run the algorithm anyways.)

Commentary on creator: our solver and unique puzzle creator run with the same exact function--might be good for further development of this project to have an independent unique-ness checker, though we are pretty confident about our algorithm.